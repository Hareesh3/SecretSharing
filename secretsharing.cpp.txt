#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <map>
#include <set>
#include <stdexcept>
#include <algorithm>
#include <sstream> // Required for string streams
#include <cstdlib> // Required for atoi

// Use the standard namespace to avoid prefixing with std::
using namespace std;

// Helper function to convert long long to string without C++11's to_string
string long_long_to_string(long long n) {
    stringstream ss;
    ss << n;
    return ss.str();
}

// --- Custom BigInt Class ---
// A self-contained class to handle arbitrarily large integer arithmetic.
class BigInt {
public:
    string number;
    bool is_negative;

    // --- Constructors ---
    BigInt() : number("0"), is_negative(false) {}
    BigInt(long long n) : number(long_long_to_string(abs(n))), is_negative(n < 0) {}
    BigInt(string s) {
        if (s.empty() || (s.length() == 1 && s[0] == '0')) {
            number = "0";
            is_negative = false;
            return;
        }
        if (s[0] == '-') {
            is_negative = true;
            number = s.substr(1);
        } else {
            is_negative = false;
            number = s;
        }
        // Remove leading zeros
        size_t first_digit = number.find_first_not_of('0');
        if (string::npos != first_digit) {
            number = number.substr(first_digit);
        } else {
            number = "0";
        }
    }

private:
    // --- Helper functions for arithmetic ---
    static string add(string n1, string n2) {
        string res = "";
        int i = n1.length() - 1, j = n2.length() - 1, carry = 0;
        while (i >= 0 || j >= 0 || carry) {
            int sum = carry + (i >= 0 ? n1[i--] - '0' : 0) + (j >= 0 ? n2[j--] - '0' : 0);
            res += (sum % 10) + '0';
            carry = sum / 10;
        }
        reverse(res.begin(), res.end());
        return res;
    }

    static string subtract(string n1, string n2) {
        string res = "";
        int i = n1.length() - 1, j = n2.length() - 1, borrow = 0;
        while (i >= 0) {
            int sub = (n1[i] - '0') - (j >= 0 ? n2[j--] - '0' : 0) - borrow;
            if (sub < 0) {
                sub += 10;
                borrow = 1;
            } else {
                borrow = 0;
            }
            res += sub + '0';
            i--;
        }
        reverse(res.begin(), res.end());
        size_t first_digit = res.find_first_not_of('0');
        if (string::npos != first_digit) {
            return res.substr(first_digit);
        }
        return "0";
    }
    
    static string multiply(string n1, string n2) {
        if (n1 == "0" || n2 == "0") return "0";
        vector<int> res(n1.length() + n2.length(), 0);
        int i_n1 = 0, i_n2 = 0;
        for (int i = n1.length() - 1; i >= 0; i--) {
            int carry = 0;
            int num1 = n1[i] - '0';
            i_n2 = 0;
            for (int j = n2.length() - 1; j >= 0; j--) {
                int num2 = n2[j] - '0';
                int sum = num1 * num2 + res[i_n1 + i_n2] + carry;
                carry = sum / 10;
                res[i_n1 + i_n2] = sum % 10;
                i_n2++;
            }
            if (carry > 0) res[i_n1 + i_n2] += carry;
            i_n1++;
        }
        int i = res.size() - 1;
        while (i >= 0 && res[i] == 0) i--;
        if (i == -1) return "0";
        string s = "";
        while (i >= 0) s += (res[i--] + '0');
        return s;
    }

    static bool is_smaller(string s1, string s2) {
        int n1 = s1.length(), n2 = s2.length();
        if (n1 < n2) return true;
        if (n2 < n1) return false;
        return s1 < s2;
    }

public:
    // --- Overloaded Operators ---
    BigInt operator+(const BigInt& other) const {
        BigInt result;
        if (is_negative == other.is_negative) {
            result.number = add(number, other.number);
            result.is_negative = is_negative;
        } else {
            if (is_smaller(number, other.number)) {
                result.number = subtract(other.number, number);
                result.is_negative = other.is_negative;
            } else {
                result.number = subtract(number, other.number);
                result.is_negative = is_negative;
            }
        }
        if (result.number == "0") result.is_negative = false;
        return result;
    }

    BigInt operator-(const BigInt& other) const {
        BigInt temp = other;
        temp.is_negative = !other.is_negative;
        return *this + temp;
    }
    
    BigInt operator*(const BigInt& other) const {
        BigInt result;
        result.number = multiply(number, other.number);
        result.is_negative = (is_negative != other.is_negative) && (result.number != "0");
        return result;
    }

    BigInt operator/(const BigInt& other) const {
        if (other.number == "0") throw runtime_error("Division by zero");
        if (is_smaller(number, other.number)) return BigInt(0);

        BigInt temp_divisor(other.number);
        BigInt quotient(0);
        BigInt current_dividend(0);
        
        string quotient_str = "";
        
        for(size_t i=0; i < number.length(); ++i) {
            current_dividend.number += number[i];
            current_dividend.number.erase(0, current_dividend.number.find_first_not_of('0'));
            if(current_dividend.number.empty()) current_dividend.number = "0";
            
            int count = 0;
            while(current_dividend >= temp_divisor) {
                current_dividend = current_dividend - temp_divisor;
                count++;
            }
            quotient_str += (count + '0');
        }
        
        quotient_str.erase(0, quotient_str.find_first_not_of('0'));
        quotient = BigInt(quotient_str.empty() ? "0" : quotient_str);
        quotient.is_negative = (is_negative != other.is_negative) && (quotient.number != "0");
        return quotient;
    }

    BigInt operator%(const BigInt& other) const {
        BigInt quotient = (*this) / other;
        BigInt remainder = (*this) - (quotient * other);
        return remainder;
    }

    // --- Comparison Operators ---
    bool operator==(const BigInt& other) const { return (number == other.number) && (is_negative == other.is_negative); }
    bool operator!=(const BigInt& other) const { return !(*this == other); }
    bool operator<(const BigInt& other) const {
        if (is_negative != other.is_negative) return is_negative;
        if (is_negative) return is_smaller(other.number, number);
        return is_smaller(number, other.number);
    }
    bool operator>(const BigInt& other) const { return !(*this < other) && !(*this == other); }
    bool operator<=(const BigInt& other) const { return (*this < other) || (*this == other); }
    bool operator>=(const BigInt& other) const { return (*this > other) || (*this == other); }
};

ostream& operator<<(ostream& os, const BigInt& b) {
    if (b.is_negative) os << "-";
    os << b.number;
    return os;
}

struct Share {
    int id;
    BigInt x;
    BigInt y;
};

BigInt string_to_bigint(const string& value_str, int base) {
    BigInt result(0);
    BigInt b(base);
    for (char c : value_str) {
        int digit;
        if (c >= '0' && c <= '9') digit = c - '0';
        else if (c >= 'a' && c <= 'f') digit = c - 'a' + 10;
        else if (c >= 'A' && c <= 'F') digit = c - 'A' + 10;
        else throw runtime_error("Invalid character in number string");
        if (digit >= base) throw runtime_error("Digit out of range for the given base");
        result = result * b + BigInt(digit);
    }
    return result;
}

BigInt calculate_secret(const vector<Share>& points) {
    BigInt secret(0);
    int k = points.size();
    for (int j = 0; j < k; ++j) {
        BigInt numerator(1);
        BigInt denominator(1);
        for (int m = 0; m < k; ++m) {
            if (j == m) continue;
            numerator = numerator * (BigInt(0) - points[m].x);
            denominator = denominator * (points[j].x - points[m].x);
        }
        if (denominator == BigInt(0) || numerator % denominator != BigInt(0)) return BigInt(0);
        BigInt term = points[j].y * (numerator / denominator);
        secret = secret + term;
    }
    return secret;
}

void find_combinations(int offset, int k, const vector<Share>& all_shares,
                       vector<Share>& current_combination,
                       map<string, int>& secret_counts,
                       map<vector<int>, string>& combination_results) {
    if (k == 0) {
        BigInt secret_bigint = calculate_secret(current_combination);
        string secret_str = (secret_bigint.is_negative ? "-" : "") + secret_bigint.number;
        secret_counts[secret_str]++;
        vector<int> ids;
        for(const auto& share : current_combination) ids.push_back(share.id);
        sort(ids.begin(), ids.end());
        combination_results[ids] = secret_str;
        return;
    }
    for (size_t i = offset; i <= all_shares.size() - k; ++i) {
        current_combination.push_back(all_shares[i]);
        find_combinations(i + 1, k - 1, all_shares, current_combination, secret_counts, combination_results);
        current_combination.pop_back();
    }
}

int main() {
    ifstream input_file("input.json");
    if (!input_file.is_open()) {
        cerr << "Error: Could not open input.json" << endl;
        return 1;
    }
    string file_content((istreambuf_iterator<char>(input_file)), istreambuf_iterator<char>());

    int n = 0, k = 0;
    vector<Share> all_shares;

    try {
        size_t n_pos = file_content.find("\"n\":");
        if(n_pos != string::npos) n = atoi(file_content.substr(n_pos + 4).c_str());

        size_t k_pos = file_content.find("\"k\":");
        if(k_pos != string::npos) k = atoi(file_content.substr(k_pos + 4).c_str());

        size_t current_pos = 0;
        while(true) {
            size_t key_start = file_content.find('"', current_pos);
            if(key_start == string::npos) break;
            size_t key_end = file_content.find('"', key_start + 1);
            if(key_end == string::npos) break;
            
            string key = file_content.substr(key_start + 1, key_end - key_start - 1);
            
            if (!isdigit(key[0])) {
                current_pos = key_end + 1;
                continue;
            }

            Share s;
            s.id = atoi(key.c_str());
            s.x = BigInt(s.id);

            size_t block_start = file_content.find('{', key_end);
            
            size_t base_pos = file_content.find("\"base\":", block_start);
            size_t base_val_start = file_content.find('"', base_pos + 7) + 1;
            size_t base_val_end = file_content.find('"', base_val_start);
            string base_str = file_content.substr(base_val_start, base_val_end - base_val_start);
            
            size_t value_pos = file_content.find("\"value\":", base_val_end);
            size_t value_val_start = file_content.find('"', value_pos + 8) + 1;
            size_t value_val_end = file_content.find('"', value_val_start);
            string value_str = file_content.substr(value_val_start, value_val_end - value_val_start);

            s.y = string_to_bigint(value_str, atoi(base_str.c_str()));
            all_shares.push_back(s);
            
            current_pos = file_content.find('}', value_val_end);
            if (current_pos == string::npos) break;
        }

    } catch (const exception& e) {
        cerr << "Error during parsing: " << e.what() << endl;
        return 1;
    }

    if (all_shares.size() != n && n != 0) {
        cerr << "Warning: The number of parsed shares (" << all_shares.size() << ") does not match 'n' (" << n << ")." << endl;
    }

    map<string, int> secret_counts;
    map<vector<int>, string> combination_results;
    vector<Share> current_combination;
    
    find_combinations(0, k, all_shares, current_combination, secret_counts, combination_results);

    string true_secret_str = "0";
    int max_count = 0;
    for (map<string, int>::const_iterator it = secret_counts.begin(); it != secret_counts.end(); ++it) {
        if (it->second > max_count) {
            max_count = it->second;
            true_secret_str = it->first;
        }
    }
    if (true_secret_str == "0" && secret_counts.size() > 1) {
        max_count = 0;
        for (map<string, int>::const_iterator it = secret_counts.begin(); it != secret_counts.end(); ++it) {
            if (it->first != "0" && it->second > max_count) {
                max_count = it->second;
                true_secret_str = it->first;
            }
        }
    }

    set<int> valid_share_ids;
    for(map<vector<int>, string>::const_iterator it = combination_results.begin(); it != combination_results.end(); ++it) {
        if (it->second == true_secret_str) {
            for(size_t i = 0; i < it->first.size(); ++i) {
                valid_share_ids.insert(it->first[i]);
            }
        }
    }
    
    vector<int> corrupt_share_ids;
    for(size_t i = 0; i < all_shares.size(); ++i) {
        if (valid_share_ids.find(all_shares[i].id) == valid_share_ids.end()) {
            corrupt_share_ids.push_back(all_shares[i].id);
        }
    }

    cout << "----------------------------------------" << endl;
    cout << "Shamir's Secret Sharing Solver Results" << endl;
    cout << " (No External Libraries Version)" << endl;
    cout << "----------------------------------------" << endl;
    cout << "Total Shares (n): " << n << endl;
    cout << "Threshold (k):    " << k << endl;
    cout << "\n>>> The calculated secret is: " << true_secret_str << endl;
    
    if (corrupt_share_ids.empty()) {
        cout << "\n>>> All shares were found to be valid." << endl;
    } else {
        cout << "\n>>> The following share(s) were identified as corrupt: ";
        for(size_t i = 0; i < corrupt_share_ids.size(); ++i) {
            cout << corrupt_share_ids[i] << (i == corrupt_share_ids.size() - 1 ? "" : ", ");
        }
        cout << endl;
    }
    cout << "----------------------------------------" << endl;

    return 0;
}